<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KOEMO ãƒ¢ãƒã‚¤ãƒ«éŸ³å£°é€šè©±ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            padding: 20px;
            background: #f2f2f7;
            margin: 0;
        }
        .container {
            max-width: 400px;
            margin: 0 auto;
        }
        h1 {
            color: #007AFF;
            text-align: center;
            font-size: 24px;
            margin-bottom: 30px;
        }
        .status {
            background: #fff;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .status.connected { background: #d4edda; }
        .status.error { background: #f8d7da; }
        .status.warning { background: #fff3cd; }
        
        button {
            width: 100%;
            background: #007AFF;
            color: white;
            border: none;
            padding: 15px;
            border-radius: 10px;
            font-size: 16px;
            margin: 10px 0;
            cursor: pointer;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        button.danger {
            background: #ff3b30;
        }
        button.success {
            background: #34c759;
        }
        
        .log {
            background: #fff;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            border: 1px solid #ddd;
        }
        
        .user-id {
            background: #e9ecef;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 14px;
            word-break: break-all;
        }
        
        .volume-indicator {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        .volume-bar {
            height: 100%;
            background: #34c759;
            width: 0%;
            transition: width 0.1s;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¯ KOEMO éŸ³å£°é€šè©±ãƒ†ã‚¹ãƒˆ</h1>
        
        <div class="user-id">
            ãƒ¦ãƒ¼ã‚¶ãƒ¼ID: <span id="userId">ç”Ÿæˆä¸­...</span>
        </div>
        
        <div id="connectionStatus" class="status">
            ğŸ“¡ æ¥ç¶šæº–å‚™ä¸­...
        </div>
        
        <button id="connectBtn" onclick="connectWebSocket()">WebSocketæ¥ç¶š</button>
        <button id="startMatchingBtn" onclick="startMatching()" disabled>ãƒãƒƒãƒãƒ³ã‚°é–‹å§‹</button>
        <button id="endCallBtn" onclick="endCall()" disabled style="display:none;">é€šè©±çµ‚äº†</button>
        
        <div id="callStatus" class="status" style="display:none;">
            é€šè©±çŠ¶æ…‹: å¾…æ©Ÿä¸­
        </div>
        
        <div id="volumeContainer" style="display:none;">
            <div>éŸ³é‡ãƒ¬ãƒ™ãƒ«:</div>
            <div class="volume-indicator">
                <div id="volumeBar" class="volume-bar"></div>
            </div>
        </div>
        
        <div id="log" class="log"></div>
    </div>

    <script>
        let ws = null;
        let localStream = null;
        let remoteStream = null;
        let peerConnection = null;
        let isMatching = false;
        let inCall = false;
        let userId = 'mobile_' + Math.random().toString(36).substr(2, 9);
        
        // Initialize
        document.getElementById('userId').textContent = userId;
        
        function log(message) {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }
        
        function updateStatus(message, type = 'normal') {
            const statusDiv = document.getElementById('connectionStatus');
            statusDiv.textContent = message;
            statusDiv.className = 'status';
            if (type === 'connected') statusDiv.classList.add('connected');
            if (type === 'error') statusDiv.classList.add('error');
            if (type === 'warning') statusDiv.classList.add('warning');
        }
        
        function updateButtons() {
            document.getElementById('connectBtn').disabled = (ws && ws.readyState === WebSocket.OPEN);
            document.getElementById('startMatchingBtn').disabled = !(ws && ws.readyState === WebSocket.OPEN) || isMatching || inCall;
            document.getElementById('endCallBtn').style.display = inCall ? 'block' : 'none';
        }
        
        async function connectWebSocket() {
            try {
                log('ğŸ”Œ WebSocketæ¥ç¶šã‚’é–‹å§‹...');
                updateStatus('ğŸ”Œ WebSocketæ¥ç¶šä¸­...', 'warning');
                
                // WebSocket URLã‚’æ§‹ç¯‰
                const wsUrl = `ws://192.168.0.8:3000/signaling?userId=${userId}`;
                log(`æ¥ç¶šå…ˆ: ${wsUrl}`);
                
                ws = new WebSocket(wsUrl);
                
                ws.onopen = function() {
                    log('âœ… WebSocketæ¥ç¶šæˆåŠŸ');
                    updateStatus('âœ… WebSocketæ¥ç¶šæ¸ˆã¿', 'connected');
                    updateButtons();
                };
                
                ws.onmessage = function(event) {
                    try {
                        const message = JSON.parse(event.data);
                        log(`ğŸ“¨ å—ä¿¡: ${message.type}`);
                        handleWebSocketMessage(message);
                    } catch (error) {
                        log(`âŒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è§£æã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    }
                };
                
                ws.onclose = function() {
                    log('âŒ WebSocketæ¥ç¶šãŒé–‰ã˜ã‚‰ã‚Œã¾ã—ãŸ');
                    updateStatus('âŒ WebSocketåˆ‡æ–­', 'error');
                    updateButtons();
                };
                
                ws.onerror = function(error) {
                    log(`âŒ WebSocketã‚¨ãƒ©ãƒ¼: ${error}`);
                    updateStatus('âŒ WebSocketæ¥ç¶šã‚¨ãƒ©ãƒ¼', 'error');
                    updateButtons();
                };
                
            } catch (error) {
                log(`âŒ WebSocketæ¥ç¶šã‚¨ãƒ©ãƒ¼: ${error.message}`);
                updateStatus('âŒ æ¥ç¶šå¤±æ•—', 'error');
            }
        }
        
        function handleWebSocketMessage(message) {
            switch (message.type) {
                case 'connected':
                    log(`ğŸ¯ ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šç¢ºèª: ${message.userId}`);
                    break;
                    
                case 'match-found':
                    log(`ğŸ‰ ãƒãƒƒãƒæˆåŠŸ! ç›¸æ‰‹: ${message.partnerId}`);
                    document.getElementById('callStatus').style.display = 'block';
                    document.getElementById('callStatus').textContent = `é€šè©±ç›¸æ‰‹: ${message.partnerId}`;
                    isMatching = false;
                    inCall = true;
                    updateButtons();
                    startCall();
                    break;
                    
                case 'match-cancelled':
                    log('âŒ ãƒãƒƒãƒãƒ³ã‚°ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ');
                    isMatching = false;
                    updateButtons();
                    break;
                    
                case 'call-ended':
                    log('ğŸ“´ é€šè©±ãŒçµ‚äº†ã—ã¾ã—ãŸ');
                    endCall();
                    break;
                    
                case 'offer':
                case 'answer':
                case 'ice-candidate':
                    handleWebRTCSignaling(message);
                    break;
                    
                default:
                    log(`â“ ä¸æ˜ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: ${message.type}`);
            }
        }
        
        async function startMatching() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('âŒ WebSocketæœªæ¥ç¶š');
                return;
            }
            
            try {
                log('ğŸ¯ ãƒãƒƒãƒãƒ³ã‚°é–‹å§‹...');
                isMatching = true;
                updateButtons();
                
                const message = {
                    type: 'start-matching',
                    profile: {
                        nickname: 'ãƒ¢ãƒã‚¤ãƒ«ãƒ¦ãƒ¼ã‚¶ãƒ¼',
                        gender: 'unknown',
                        age: 25,
                        region: 'Mobile'
                    }
                };
                
                ws.send(JSON.stringify(message));
                log('ğŸ“¤ ãƒãƒƒãƒãƒ³ã‚°ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡');
                updateStatus('ğŸ” ãƒãƒƒãƒãƒ³ã‚°ä¸­...', 'warning');
                
            } catch (error) {
                log(`âŒ ãƒãƒƒãƒãƒ³ã‚°é–‹å§‹ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                isMatching = false;
                updateButtons();
            }
        }
        
        async function startCall() {
            try {
                log('ğŸ¤ éŸ³å£°ãƒ‡ãƒã‚¤ã‚¹åˆæœŸåŒ–...');
                
                // ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                log('âœ… ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯å–å¾—');
                
                // éŸ³é‡è¡¨ç¤º
                document.getElementById('volumeContainer').style.display = 'block';
                setupVolumeIndicator();
                
                // WebRTCåˆæœŸåŒ–ã¯ç°¡ç•¥åŒ–ï¼ˆãƒ‡ãƒ¢ç”¨ï¼‰
                log('ğŸ“ éŸ³å£°é€šè©±æº–å‚™å®Œäº†');
                updateStatus('ğŸ“ éŸ³å£°é€šè©±ä¸­', 'connected');
                
            } catch (error) {
                log(`âŒ éŸ³å£°åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                updateStatus('âŒ éŸ³å£°ã‚¨ãƒ©ãƒ¼', 'error');
            }
        }
        
        function setupVolumeIndicator() {
            if (!localStream) return;
            
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(localStream);
            const analyser = audioContext.createAnalyser();
            
            source.connect(analyser);
            analyser.fftSize = 256;
            
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            
            function updateVolume() {
                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                const volumePercent = (average / 255) * 100;
                
                document.getElementById('volumeBar').style.width = volumePercent + '%';
                
                if (inCall) {
                    requestAnimationFrame(updateVolume);
                }
            }
            
            updateVolume();
        }
        
        function handleWebRTCSignaling(message) {
            log(`ğŸ”„ WebRTCã‚·ã‚°ãƒŠãƒªãƒ³ã‚°: ${message.type}`);
            // WebRTCå®Ÿè£…ã¯ç°¡ç•¥åŒ–ï¼ˆãƒ‡ãƒ¢ç”¨ï¼‰
        }
        
        function endCall() {
            try {
                log('ğŸ“´ é€šè©±çµ‚äº†å‡¦ç†...');
                
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'end-call' }));
                }
                
                inCall = false;
                isMatching = false;
                document.getElementById('callStatus').style.display = 'none';
                document.getElementById('volumeContainer').style.display = 'none';
                updateButtons();
                updateStatus('âœ… WebSocketæ¥ç¶šæ¸ˆã¿', 'connected');
                
                log('âœ… é€šè©±çµ‚äº†å®Œäº†');
                
            } catch (error) {
                log(`âŒ é€šè©±çµ‚äº†ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }
        
        // è‡ªå‹•æ¥ç¶š
        window.onload = function() {
            log('ğŸ“± ãƒ¢ãƒã‚¤ãƒ«éŸ³å£°é€šè©±ãƒ†ã‚¹ãƒˆé–‹å§‹');
            updateButtons();
        };
        
        // Page visibility API
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                log('ğŸ“µ ãƒšãƒ¼ã‚¸ãŒéè¡¨ç¤ºã«ãªã‚Šã¾ã—ãŸ');
            } else {
                log('ğŸ“± ãƒšãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã¾ã—ãŸ');
            }
        });
    </script>
</body>
</html>