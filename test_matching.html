<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KOEMO ãƒãƒƒãƒãƒ³ã‚° + WebRTC ãƒ†ã‚¹ãƒˆ v2.1</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f7;
            color: #1d1d1f;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .user-panel {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .dual-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        h1 {
            text-align: center;
            color: #007AFF;
            font-size: 28px;
            margin-bottom: 30px;
        }
        
        h2 {
            color: #007AFF;
            border-bottom: 2px solid #007AFF;
            padding-bottom: 10px;
        }
        
        .status {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-weight: 500;
        }
        
        .status.connected {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.disconnected {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.matching {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .status.matched {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        label {
            display: block;
            font-weight: 500;
            margin-bottom: 6px;
            color: #1d1d1f;
        }
        
        input, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e5e5e7;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #007AFF;
        }
        
        button {
            background-color: #007AFF;
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-bottom: 12px;
        }
        
        button:hover {
            background-color: #0056CC;
        }
        
        button:disabled {
            background-color: #c7c7cc;
            cursor: not-allowed;
        }
        
        .secondary {
            background-color: #8e8e93;
        }
        
        .secondary:hover {
            background-color: #6d6d70;
        }
        
        .danger {
            background-color: #ff3b30;
        }
        
        .danger:hover {
            background-color: #d70015;
        }
        
        .success {
            background-color: #30d158;
        }
        
        .success:hover {
            background-color: #28a745;
        }
        
        .log {
            background-color: #1d1d1f;
            color: #f5f5f7;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            padding: 16px;
            border-radius: 8px;
            height: 200px;
            overflow-y: auto;
            font-size: 12px;
            white-space: pre-wrap;
        }
        
        .partner-info {
            background-color: #f0f9ff;
            border: 2px solid #007AFF;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        
        .audio-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .audio-controls button {
            flex: 1;
            min-width: 120px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }
        
        .stat-item {
            background-color: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007AFF;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .match-countdown {
            background-color: #fff3cd;
            border: 2px solid #ffeaa7;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            text-align: center;
        }
        
        .countdown-timer {
            font-size: 24px;
            font-weight: bold;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¯ KOEMO ãƒãƒƒãƒãƒ³ã‚° + WebRTC ãƒ†ã‚¹ãƒˆ</h1>
        
        <div class="dual-panel">
            <!-- User 1 Panel -->
            <div class="user-panel">
                <h2>ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼1 (ãƒ–ãƒ©ã‚¦ã‚¶)</h2>
                
                <div class="status disconnected" id="status1">
                    ğŸ“µ æœªæ¥ç¶š
                </div>
                
                <!-- Profile Settings -->
                <div class="form-group">
                    <label for="nickname1">ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ :</label>
                    <input type="text" id="nickname1" value="ãƒ–ãƒ©ã‚¦ã‚¶ãƒ¦ãƒ¼ã‚¶ãƒ¼">
                </div>
                
                <div class="form-group">
                    <label for="gender1">æ€§åˆ¥:</label>
                    <select id="gender1">
                        <option value="male">ç”·æ€§</option>
                        <option value="female">å¥³æ€§</option>
                        <option value="other">ãã®ä»–</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="age1">å¹´é½¢:</label>
                    <input type="number" id="age1" value="25" min="18" max="99">
                </div>
                
                <div class="form-group">
                    <label for="region1">åœ°åŸŸ:</label>
                    <input type="text" id="region1" value="æ±äº¬éƒ½">
                </div>
                
                <!-- Connection Controls -->
                <button onclick="connectUser1()" id="connectBtn1">æ¥ç¶š</button>
                <button onclick="startMatching1()" id="matchBtn1" disabled>ãƒãƒƒãƒãƒ³ã‚°é–‹å§‹</button>
                <button onclick="cancelMatching1()" id="cancelBtn1" disabled>ãƒãƒƒãƒãƒ³ã‚°å–æ¶ˆ</button>
                
                <!-- Match Controls (hidden initially) -->
                <div id="matchControls1" style="display: none;">
                    <div class="partner-info" id="partnerInfo1"></div>
                    <div class="match-countdown" id="countdown1" style="display: none;">
                        <div class="countdown-timer" id="countdownTimer1">10</div>
                        <div>ç§’å¾Œã«è‡ªå‹•æ¥ç¶šã—ã¾ã™</div>
                    </div>
                    <div class="audio-controls">
                        <button onclick="acceptMatch1()" id="acceptBtn1" class="success">é€šè©±é–‹å§‹</button>
                        <button onclick="rejectMatch1()" id="rejectBtn1" class="danger">ã‚¹ã‚­ãƒƒãƒ—</button>
                    </div>
                </div>
                
                <!-- WebRTC Audio Controls -->
                <div id="audioControls1" style="display: none;">
                    <h3>ğŸµ éŸ³å£°ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«</h3>
                    <div class="audio-controls">
                        <button onclick="toggleMute1()" id="muteBtn1">ğŸ¤ ãƒŸãƒ¥ãƒ¼ãƒˆ</button>
                        <button onclick="toggleSpeaker1()" id="speakerBtn1">ğŸ“¢ ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼</button>
                        <button onclick="endCall1()" id="endCallBtn1" class="danger">é€šè©±çµ‚äº†</button>
                    </div>
                    <audio id="remoteAudio1" autoplay></audio>
                </div>
                
                <div id="log1" class="log"></div>
            </div>
            
            <!-- User 2 Panel -->
            <div class="user-panel">
                <h2>ğŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼2 (ãƒ–ãƒ©ã‚¦ã‚¶)</h2>
                
                <div class="status disconnected" id="status2">
                    ğŸ“µ æœªæ¥ç¶š
                </div>
                
                <!-- Profile Settings -->
                <div class="form-group">
                    <label for="nickname2">ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ :</label>
                    <input type="text" id="nickname2" value="ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼">
                </div>
                
                <div class="form-group">
                    <label for="gender2">æ€§åˆ¥:</label>
                    <select id="gender2">
                        <option value="male">ç”·æ€§</option>
                        <option value="female" selected>å¥³æ€§</option>
                        <option value="other">ãã®ä»–</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="age2">å¹´é½¢:</label>
                    <input type="number" id="age2" value="28" min="18" max="99">
                </div>
                
                <div class="form-group">
                    <label for="region2">åœ°åŸŸ:</label>
                    <input type="text" id="region2" value="å¤§é˜ªåºœ">
                </div>
                
                <!-- Connection Controls -->
                <button onclick="connectUser2()" id="connectBtn2">æ¥ç¶š</button>
                <button onclick="startMatching2()" id="matchBtn2" disabled>ãƒãƒƒãƒãƒ³ã‚°é–‹å§‹</button>
                <button onclick="cancelMatching2()" id="cancelBtn2" disabled>ãƒãƒƒãƒãƒ³ã‚°å–æ¶ˆ</button>
                
                <!-- Match Controls (hidden initially) -->
                <div id="matchControls2" style="display: none;">
                    <div class="partner-info" id="partnerInfo2"></div>
                    <div class="match-countdown" id="countdown2" style="display: none;">
                        <div class="countdown-timer" id="countdownTimer2">10</div>
                        <div>ç§’å¾Œã«è‡ªå‹•æ¥ç¶šã—ã¾ã™</div>
                    </div>
                    <div class="audio-controls">
                        <button onclick="acceptMatch2()" id="acceptBtn2" class="success">é€šè©±é–‹å§‹</button>
                        <button onclick="rejectMatch2()" id="rejectBtn2" class="danger">ã‚¹ã‚­ãƒƒãƒ—</button>
                    </div>
                </div>
                
                <!-- WebRTC Audio Controls -->
                <div id="audioControls2" style="display: none;">
                    <h3>ğŸµ éŸ³å£°ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«</h3>
                    <div class="audio-controls">
                        <button onclick="toggleMute2()" id="muteBtn2">ğŸ¤ ãƒŸãƒ¥ãƒ¼ãƒˆ</button>
                        <button onclick="toggleSpeaker2()" id="speakerBtn2">ğŸ“¢ ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼</button>
                        <button onclick="endCall2()" id="endCallBtn2" class="danger">é€šè©±çµ‚äº†</button>
                    </div>
                    <audio id="remoteAudio2" autoplay></audio>
                </div>
                
                <div id="log2" class="log"></div>
            </div>
        </div>
        
        <!-- Global Stats -->
        <div class="user-panel">
            <h2>ğŸ“Š ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ çµ±è¨ˆ</h2>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="waitingCount">0</div>
                    <div class="stat-label">å¾…æ©Ÿä¸­</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="activeMatches">0</div>
                    <div class="stat-label">é€šè©±ä¸­</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="connectedUsers">0</div>
                    <div class="stat-label">æ¥ç¶šä¸­</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Check browser support
        function checkBrowserSupport() {
            const errors = [];
            
            if (!window.WebSocket) {
                errors.push('WebSocket not supported');
            }
            
            if (!window.RTCPeerConnection) {
                errors.push('WebRTC not supported');
            }
            
            if (!navigator.mediaDevices) {
                errors.push('MediaDevices API not supported');
            }
            
            if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                errors.push('WebRTC requires HTTPS or localhost');
            }
            
            if (errors.length > 0) {
                alert('ãƒ–ãƒ©ã‚¦ã‚¶ã‚µãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼:\\n' + errors.join('\\n'));
                return false;
            }
            
            console.log('âœ… Browser support check passed');
            return true;
        }
        
        // Global variables
        let ws1 = null, ws2 = null;
        let pc1 = null, pc2 = null;
        let localStream1 = null, localStream2 = null;
        let currentMatch1 = null, currentMatch2 = null;
        let countdownInterval1 = null, countdownInterval2 = null;
        let isMuted1 = false, isMuted2 = false;
        let isSpeakerOn1 = false, isSpeakerOn2 = false;
        let isInCall1 = false, isInCall2 = false;
        let currentRoomId1 = null, currentRoomId2 = null;
        
        const servers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Utility functions
        function log(userId, message) {
            const logElement = document.getElementById(`log${userId}`);
            const timestamp = new Date().toLocaleTimeString();
            logElement.textContent += `[${timestamp}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        function updateStatus(userId, status, className = '') {
            const statusElement = document.getElementById(`status${userId}`);
            statusElement.textContent = status;
            statusElement.className = `status ${className}`;
        }

        function getProfile(userId) {
            return {
                nickname: document.getElementById(`nickname${userId}`).value,
                gender: document.getElementById(`gender${userId}`).value,
                age: parseInt(document.getElementById(`age${userId}`).value),
                region: document.getElementById(`region${userId}`).value,
                deviceId: `browser_user_${userId}`
            };
        }

        // WebSocket connection functions
        async function connectUser1() {
            const userId = 'browser_user_1';
            ws1 = new WebSocket(`ws://localhost:3000/signaling?userId=${userId}`);
            
            ws1.onopen = () => {
                log(1, 'âœ… WebSocketæ¥ç¶šæˆåŠŸ');
                updateStatus(1, 'ğŸ”— æ¥ç¶šæ¸ˆã¿', 'connected');
                document.getElementById('connectBtn1').disabled = true;
                document.getElementById('matchBtn1').disabled = false;
            };
            
            ws1.onmessage = (event) => {
                const message = JSON.parse(event.data);
                handleMessage1(message);
            };
            
            ws1.onclose = () => {
                log(1, 'âŒ WebSocketæ¥ç¶šåˆ‡æ–­');
                updateStatus(1, 'ğŸ“µ åˆ‡æ–­', 'disconnected');
                document.getElementById('connectBtn1').disabled = false;
                document.getElementById('matchBtn1').disabled = true;
            };
            
            ws1.onerror = (error) => {
                log(1, `âŒ WebSocket ã‚¨ãƒ©ãƒ¼: ${error}`);
            };
        }

        async function connectUser2() {
            const userId = 'browser_user_2';
            ws2 = new WebSocket(`ws://localhost:3000/signaling?userId=${userId}`);
            
            ws2.onopen = () => {
                log(2, 'âœ… WebSocketæ¥ç¶šæˆåŠŸ');
                updateStatus(2, 'ğŸ”— æ¥ç¶šæ¸ˆã¿', 'connected');
                document.getElementById('connectBtn2').disabled = true;
                document.getElementById('matchBtn2').disabled = false;
            };
            
            ws2.onmessage = (event) => {
                const message = JSON.parse(event.data);
                handleMessage2(message);
            };
            
            ws2.onclose = () => {
                log(2, 'âŒ WebSocketæ¥ç¶šåˆ‡æ–­');
                updateStatus(2, 'ğŸ“µ åˆ‡æ–­', 'disconnected');
                document.getElementById('connectBtn2').disabled = false;
                document.getElementById('matchBtn2').disabled = true;
            };
            
            ws2.onerror = (error) => {
                log(2, `âŒ WebSocket ã‚¨ãƒ©ãƒ¼: ${error}`);
            };
        }

        // Matching functions
        function startMatching1() {
            if (ws1) {
                const profile = getProfile(1);
                ws1.send(JSON.stringify({
                    type: 'start-matching',
                    profile: profile
                }));
                
                updateStatus(1, 'ğŸ” ãƒãƒƒãƒãƒ³ã‚°ä¸­...', 'matching');
                document.getElementById('matchBtn1').disabled = true;
                document.getElementById('cancelBtn1').disabled = false;
                log(1, 'ğŸ¯ ãƒãƒƒãƒãƒ³ã‚°é–‹å§‹');
            }
        }

        function startMatching2() {
            if (ws2) {
                const profile = getProfile(2);
                ws2.send(JSON.stringify({
                    type: 'start-matching',
                    profile: profile
                }));
                
                updateStatus(2, 'ğŸ” ãƒãƒƒãƒãƒ³ã‚°ä¸­...', 'matching');
                document.getElementById('matchBtn2').disabled = true;
                document.getElementById('cancelBtn2').disabled = false;
                log(2, 'ğŸ¯ ãƒãƒƒãƒãƒ³ã‚°é–‹å§‹');
            }
        }

        function cancelMatching1() {
            if (ws1) {
                ws1.send(JSON.stringify({
                    type: 'cancel-matching'
                }));
                
                resetMatchingState1();
                log(1, 'âŒ ãƒãƒƒãƒãƒ³ã‚°ã‚­ãƒ£ãƒ³ã‚»ãƒ«');
            }
        }

        function cancelMatching2() {
            if (ws2) {
                ws2.send(JSON.stringify({
                    type: 'cancel-matching'
                }));
                
                resetMatchingState2();
                log(2, 'âŒ ãƒãƒƒãƒãƒ³ã‚°ã‚­ãƒ£ãƒ³ã‚»ãƒ«');
            }
        }

        function acceptMatch1() {
            if (ws1 && currentMatch1) {
                ws1.send(JSON.stringify({
                    type: 'accept-match',
                    matchId: currentMatch1.matchId
                }));
                
                log(1, 'âœ… ãƒãƒƒãƒå—è«¾');
                clearCountdown1();
            }
        }

        function acceptMatch2() {
            if (ws2 && currentMatch2) {
                ws2.send(JSON.stringify({
                    type: 'accept-match',
                    matchId: currentMatch2.matchId
                }));
                
                log(2, 'âœ… ãƒãƒƒãƒå—è«¾');
                clearCountdown2();
            }
        }

        function rejectMatch1() {
            if (ws1 && currentMatch1) {
                ws1.send(JSON.stringify({
                    type: 'reject-match',
                    matchId: currentMatch1.matchId
                }));
                
                log(1, 'âŒ ãƒãƒƒãƒæ‹’å¦');
                resetMatchingState1();
            }
        }

        function rejectMatch2() {
            if (ws2 && currentMatch2) {
                ws2.send(JSON.stringify({
                    type: 'reject-match',
                    matchId: currentMatch2.matchId
                }));
                
                log(2, 'âŒ ãƒãƒƒãƒæ‹’å¦');
                resetMatchingState2();
            }
        }

        // Message handlers
        function handleMessage1(message) {
            log(1, `ğŸ“¨ å—ä¿¡: ${message.type}`);
            
            switch (message.type) {
                case 'connected':
                    log(1, `âœ… ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šç¢ºèª: ${message.userId}`);
                    break;
                    
                case 'matching-status':
                    log(1, `ğŸ“Š ãƒãƒƒãƒãƒ³ã‚°çŠ¶æ³: ${message.status} (å¾…æ©Ÿ: ${message.queuePosition})`);
                    break;
                    
                case 'match-found':
                    currentMatch1 = message;
                    showMatch1(message);
                    break;
                    
                case 'start-call':
                    log(1, `ğŸ“ é€šè©±é–‹å§‹: ${message.roomId}`);
                    startWebRTCCall1(message);
                    break;
                    
                case 'joined-room':
                    log(1, `ğŸ  ãƒ«ãƒ¼ãƒ å‚åŠ : ${message.roomId} (${message.participantCount}/2)`);
                    break;
                    
                case 'room-ready':
                    log(1, `âœ… ãƒ«ãƒ¼ãƒ æº–å‚™å®Œäº† - å‚åŠ è€…: ${message.participants.length}`);
                    // Room is ready, initiator creates offer
                    if (message.participants[0] === 'browser_user_1') {
                        setTimeout(() => createOffer1(), 1000);
                    }
                    break;
                    
                case 'match-cancelled':
                    log(1, `âŒ ãƒãƒƒãƒã‚­ãƒ£ãƒ³ã‚»ãƒ«: ${message.reason}`);
                    resetMatchingState1();
                    break;
                    
                case 'offer':
                    handleOffer1(message);
                    break;
                    
                case 'answer':
                    handleAnswer1(message);
                    break;
                    
                case 'ice-candidate':
                    handleIceCandidate1(message);
                    break;
                    
                default:
                    log(1, `âš ï¸ æœªçŸ¥ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—: ${message.type}`);
            }
        }

        function handleMessage2(message) {
            log(2, `ğŸ“¨ å—ä¿¡: ${message.type}`);
            
            switch (message.type) {
                case 'connected':
                    log(2, `âœ… ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šç¢ºèª: ${message.userId}`);
                    break;
                    
                case 'matching-status':
                    log(2, `ğŸ“Š ãƒãƒƒãƒãƒ³ã‚°çŠ¶æ³: ${message.status} (å¾…æ©Ÿ: ${message.queuePosition})`);
                    break;
                    
                case 'match-found':
                    currentMatch2 = message;
                    showMatch2(message);
                    break;
                    
                case 'start-call':
                    log(2, `ğŸ“ é€šè©±é–‹å§‹: ${message.roomId}`);
                    startWebRTCCall2(message);
                    break;
                    
                case 'joined-room':
                    log(2, `ğŸ  ãƒ«ãƒ¼ãƒ å‚åŠ : ${message.roomId} (${message.participantCount}/2)`);
                    break;
                    
                case 'room-ready':
                    log(2, `âœ… ãƒ«ãƒ¼ãƒ æº–å‚™å®Œäº† - å‚åŠ è€…: ${message.participants.length}`);
                    // Room is ready, initiator creates offer
                    if (message.participants[0] === 'browser_user_2') {
                        setTimeout(() => createOffer2(), 1000);
                    }
                    break;
                    
                case 'match-cancelled':
                    log(2, `âŒ ãƒãƒƒãƒã‚­ãƒ£ãƒ³ã‚»ãƒ«: ${message.reason}`);
                    resetMatchingState2();
                    break;
                    
                case 'offer':
                    handleOffer2(message);
                    break;
                    
                case 'answer':
                    handleAnswer2(message);
                    break;
                    
                case 'ice-candidate':
                    handleIceCandidate2(message);
                    break;
                    
                default:
                    log(2, `âš ï¸ æœªçŸ¥ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—: ${message.type}`);
            }
        }

        // Match display functions
        function showMatch1(match) {
            updateStatus(1, 'ğŸ‰ ãƒãƒƒãƒæˆç«‹ï¼', 'matched');
            
            const partnerInfo = document.getElementById('partnerInfo1');
            partnerInfo.innerHTML = `
                <h3>ğŸ‘¤ ãƒãƒƒãƒã—ãŸç›¸æ‰‹</h3>
                <p><strong>ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ :</strong> ${match.partner.nickname}</p>
                <p><strong>æ€§åˆ¥:</strong> ${match.partner.gender}</p>
                <p><strong>å¹´é½¢:</strong> ${match.partner.age}æ­³</p>
                <p><strong>åœ°åŸŸ:</strong> ${match.partner.region}</p>
            `;
            
            document.getElementById('matchControls1').style.display = 'block';
            startCountdown1();
            log(1, `ğŸ‰ ãƒãƒƒãƒæˆç«‹: ${match.partner.nickname}`);
        }

        function showMatch2(match) {
            updateStatus(2, 'ğŸ‰ ãƒãƒƒãƒæˆç«‹ï¼', 'matched');
            
            const partnerInfo = document.getElementById('partnerInfo2');
            partnerInfo.innerHTML = `
                <h3>ğŸ‘¤ ãƒãƒƒãƒã—ãŸç›¸æ‰‹</h3>
                <p><strong>ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ :</strong> ${match.partner.nickname}</p>
                <p><strong>æ€§åˆ¥:</strong> ${match.partner.gender}</p>
                <p><strong>å¹´é½¢:</strong> ${match.partner.age}æ­³</p>
                <p><strong>åœ°åŸŸ:</strong> ${match.partner.region}</p>
            `;
            
            document.getElementById('matchControls2').style.display = 'block';
            startCountdown2();
            log(2, `ğŸ‰ ãƒãƒƒãƒæˆç«‹: ${match.partner.nickname}`);
        }

        // Countdown functions
        function startCountdown1() {
            let seconds = 10;
            document.getElementById('countdown1').style.display = 'block';
            document.getElementById('countdownTimer1').textContent = seconds;
            
            countdownInterval1 = setInterval(() => {
                seconds--;
                document.getElementById('countdownTimer1').textContent = seconds;
                
                if (seconds <= 0) {
                    clearInterval(countdownInterval1);
                    acceptMatch1();
                }
            }, 1000);
        }

        function startCountdown2() {
            let seconds = 10;
            document.getElementById('countdown2').style.display = 'block';
            document.getElementById('countdownTimer2').textContent = seconds;
            
            countdownInterval2 = setInterval(() => {
                seconds--;
                document.getElementById('countdownTimer2').textContent = seconds;
                
                if (seconds <= 0) {
                    clearInterval(countdownInterval2);
                    acceptMatch2();
                }
            }, 1000);
        }

        function clearCountdown1() {
            if (countdownInterval1) {
                clearInterval(countdownInterval1);
                countdownInterval1 = null;
            }
            document.getElementById('countdown1').style.display = 'none';
        }

        function clearCountdown2() {
            if (countdownInterval2) {
                clearInterval(countdownInterval2);
                countdownInterval2 = null;
            }
            document.getElementById('countdown2').style.display = 'none';
        }

        // WebRTC functions
        async function startWebRTCCall1(callMessage) {
            try {
                updateStatus(1, 'ğŸ“ é€šè©±æ¥ç¶šä¸­...', 'connected');
                
                // Check WebRTC support
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    log(1, 'âš ï¸ WebRTC APIãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚HTTPSã¾ãŸã¯localhostã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãã ã•ã„ã€‚');
                    log(1, 'ğŸ“± ç¾åœ¨ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«: ' + window.location.protocol);
                    
                    // Try to proceed without getUserMedia for testing
                    log(1, 'ğŸ”§ ãƒã‚¤ã‚¯ãªã—ã§WebRTCæ¥ç¶šã‚’è©¦è¡Œã—ã¾ã™...');
                    
                    // Create peer connection without local stream
                    pc1 = new RTCPeerConnection(servers);
                    
                    // Create a dummy audio track if possible
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const dst = oscillator.connect(audioContext.createMediaStreamDestination());
                        localStream1 = dst.stream;
                        
                        localStream1.getTracks().forEach(track => {
                            pc1.addTrack(track, localStream1);
                        });
                        log(1, 'ğŸµ ãƒ€ãƒŸãƒ¼éŸ³å£°ãƒˆãƒ©ãƒƒã‚¯ä½œæˆ');
                    } catch (e) {
                        log(1, 'âš ï¸ ãƒ€ãƒŸãƒ¼ãƒˆãƒ©ãƒƒã‚¯ä½œæˆå¤±æ•—: ' + e.message);
                    }
                } else {
                    // Get user media normally
                    localStream1 = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    log(1, 'ğŸ¤ ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹å–å¾—');
                    
                    // Create peer connection
                    pc1 = new RTCPeerConnection(servers);
                    
                    // Add local stream
                    localStream1.getTracks().forEach(track => {
                        pc1.addTrack(track, localStream1);
                    });
                }
                
                // Handle remote stream
                pc1.ontrack = (event) => {
                    log(1, 'ğŸµ ãƒªãƒ¢ãƒ¼ãƒˆéŸ³å£°å—ä¿¡');
                    const remoteAudio = document.getElementById('remoteAudio1');
                    remoteAudio.srcObject = event.streams[0];
                    remoteAudio.play().catch(e => log(1, `éŸ³å£°å†ç”Ÿã‚¨ãƒ©ãƒ¼: ${e.message}`));
                };
                
                // Handle ICE candidates
                pc1.onicecandidate = (event) => {
                    if (event.candidate && ws1) {
                        ws1.send(JSON.stringify({
                            type: 'ice-candidate',
                            candidate: {
                                candidate: event.candidate.candidate,
                                sdpMLineIndex: event.candidate.sdpMLineIndex,
                                sdpMid: event.candidate.sdpMid
                            }
                        }));
                        log(1, 'ğŸ§Š ICEå€™è£œé€ä¿¡');
                    }
                };
                
                // Join WebRTC room
                ws1.send(JSON.stringify({
                    type: 'join-room',
                    roomId: callMessage.roomId
                }));
                
                // If initiator, create offer
                if (callMessage.isInitiator) {
                    log(1, 'ğŸ“¤ ã‚ªãƒ•ã‚¡ãƒ¼ä½œæˆä¸­...');
                    setTimeout(async () => {
                        const offer = await pc1.createOffer();
                        await pc1.setLocalDescription(offer);
                        
                        ws1.send(JSON.stringify({
                            type: 'offer',
                            offer: offer.sdp
                        }));
                        log(1, 'ğŸ“¤ ã‚ªãƒ•ã‚¡ãƒ¼é€ä¿¡');
                    }, 1000);
                }
                
                showAudioControls1();
                hideMatchControls1();
                
            } catch (error) {
                log(1, `âŒ WebRTCé–‹å§‹ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }

        async function startWebRTCCall2(callMessage) {
            try {
                updateStatus(2, 'ğŸ“ é€šè©±æ¥ç¶šä¸­...', 'connected');
                
                // Check WebRTC support
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    log(2, 'âš ï¸ WebRTC APIãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚HTTPSã¾ãŸã¯localhostã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãã ã•ã„ã€‚');
                    log(2, 'ğŸ“± ç¾åœ¨ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«: ' + window.location.protocol);
                    
                    // Try to proceed without getUserMedia for testing
                    log(2, 'ğŸ”§ ãƒã‚¤ã‚¯ãªã—ã§WebRTCæ¥ç¶šã‚’è©¦è¡Œã—ã¾ã™...');
                    
                    // Create peer connection without local stream
                    pc2 = new RTCPeerConnection(servers);
                    
                    // Create a dummy audio track if possible
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const dst = oscillator.connect(audioContext.createMediaStreamDestination());
                        localStream2 = dst.stream;
                        
                        localStream2.getTracks().forEach(track => {
                            pc2.addTrack(track, localStream2);
                        });
                        log(2, 'ğŸµ ãƒ€ãƒŸãƒ¼éŸ³å£°ãƒˆãƒ©ãƒƒã‚¯ä½œæˆ');
                    } catch (e) {
                        log(2, 'âš ï¸ ãƒ€ãƒŸãƒ¼ãƒˆãƒ©ãƒƒã‚¯ä½œæˆå¤±æ•—: ' + e.message);
                    }
                } else {
                    // Get user media normally
                    localStream2 = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    log(2, 'ğŸ¤ ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹å–å¾—');
                    
                    // Create peer connection
                    pc2 = new RTCPeerConnection(servers);
                    
                    // Add local stream
                    localStream2.getTracks().forEach(track => {
                        pc2.addTrack(track, localStream2);
                    });
                }
                
                // Handle remote stream
                pc2.ontrack = (event) => {
                    log(2, 'ğŸµ ãƒªãƒ¢ãƒ¼ãƒˆéŸ³å£°å—ä¿¡');
                    const remoteAudio = document.getElementById('remoteAudio2');
                    remoteAudio.srcObject = event.streams[0];
                    remoteAudio.play().catch(e => log(2, `éŸ³å£°å†ç”Ÿã‚¨ãƒ©ãƒ¼: ${e.message}`));
                };
                
                // Handle ICE candidates
                pc2.onicecandidate = (event) => {
                    if (event.candidate && ws2) {
                        ws2.send(JSON.stringify({
                            type: 'ice-candidate',
                            candidate: {
                                candidate: event.candidate.candidate,
                                sdpMLineIndex: event.candidate.sdpMLineIndex,
                                sdpMid: event.candidate.sdpMid
                            }
                        }));
                        log(2, 'ğŸ§Š ICEå€™è£œé€ä¿¡');
                    }
                };
                
                // Join WebRTC room
                ws2.send(JSON.stringify({
                    type: 'join-room',
                    roomId: callMessage.roomId
                }));
                
                // If initiator, create offer
                if (callMessage.isInitiator) {
                    log(2, 'ğŸ“¤ ã‚ªãƒ•ã‚¡ãƒ¼ä½œæˆä¸­...');
                    setTimeout(async () => {
                        const offer = await pc2.createOffer();
                        await pc2.setLocalDescription(offer);
                        
                        ws2.send(JSON.stringify({
                            type: 'offer',
                            offer: offer.sdp
                        }));
                        log(2, 'ğŸ“¤ ã‚ªãƒ•ã‚¡ãƒ¼é€ä¿¡');
                    }, 1000);
                }
                
                showAudioControls2();
                hideMatchControls2();
                
            } catch (error) {
                log(2, `âŒ WebRTCé–‹å§‹ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }

        // WebRTC message handlers
        async function handleOffer1(message) {
            console.log('ğŸ” DEBUG: handleOffer1 called with message:', message);
            log(1, 'ğŸ” DEBUG: handleOffer1 called with message: ' + JSON.stringify(message));
            
            try {
                if (!pc1) {
                    log(1, 'âŒ PeerConnectionãŒå­˜åœ¨ã—ã¾ã›ã‚“');
                    return;
                }
                
                log(1, 'ğŸ“¥ ã‚ªãƒ•ã‚¡ãƒ¼å—ä¿¡ã€å›ç­”ä½œæˆä¸­...');
                
                // Extract offer SDP from message structure
                let offerSdp = null;
                let offerType = 'offer';
                
                console.log('ğŸ” DEBUG: message.offer type:', typeof message.offer);
                console.log('ğŸ” DEBUG: message.offer value:', message.offer);
                
                // Handle various offer formats - iOS sends just the SDP string
                if (typeof message.offer === 'string') {
                    offerSdp = message.offer;
                    console.log('ğŸ” DEBUG: Using direct string offer');
                } else if (message.offer && typeof message.offer === 'object') {
                    if (typeof message.offer.sdp === 'string') {
                        offerSdp = message.offer.sdp;
                        offerType = message.offer.type || 'offer';
                        console.log('ğŸ” DEBUG: Using offer.sdp');
                    } else {
                        // Try other possible structures
                        offerSdp = message.offer.offer || message.offer;
                        console.log('ğŸ” DEBUG: Using offer.offer fallback');
                    }
                } else {
                    log(1, 'âŒ ç„¡åŠ¹ãªã‚ªãƒ•ã‚¡ãƒ¼å½¢å¼ - ã‚ªãƒ•ã‚¡ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    console.error('âŒ Invalid offer format - full message:', message);
                    return;
                }
                
                // Validate SDP string
                if (!offerSdp || typeof offerSdp !== 'string' || offerSdp.length < 10) {
                    log(1, 'âŒ ç„¡åŠ¹ãªSDPæ–‡å­—åˆ—');
                    console.error('âŒ Invalid SDP string:', {
                        type: typeof offerSdp,
                        length: offerSdp ? offerSdp.length : 'undefined',
                        value: offerSdp
                    });
                    return;
                }
                
                log(1, 'âœ… ã‚ªãƒ•ã‚¡ãƒ¼SDPæŠ½å‡ºæˆåŠŸ: ' + offerSdp.substring(0, 100) + '...');
                console.log('âœ… Successfully extracted SDP:', offerSdp.substring(0, 200));
                
                // Create RTCSessionDescription with proper validation
                let offer;
                try {
                    offer = new RTCSessionDescription({
                        type: offerType,
                        sdp: offerSdp
                    });
                    console.log('âœ… RTCSessionDescription created successfully');
                } catch (error) {
                    log(1, 'âŒ RTCSessionDescriptionä½œæˆã‚¨ãƒ©ãƒ¼: ' + error.message);
                    console.error('âŒ RTCSessionDescription creation error:', error);
                    console.error('âŒ SDP used:', offerSdp.substring(0, 200));
                    return;
                }
                
                await pc1.setRemoteDescription(offer);
                log(1, 'âœ… ãƒªãƒ¢ãƒ¼ãƒˆè¨˜è¿°è¨­å®šå®Œäº†');
                
                // Process any pending ICE candidates
                if (window.pendingIceCandidates1) {
                    for (const pendingCandidate of window.pendingIceCandidates1) {
                        await handleIceCandidate1(pendingCandidate);
                    }
                    window.pendingIceCandidates1 = [];
                    log(1, 'âœ… ä¿ç•™ä¸­ã®ICEå€™è£œã‚’å‡¦ç†ã—ã¾ã—ãŸ');
                }
                
                const answer = await pc1.createAnswer();
                await pc1.setLocalDescription(answer);
                
                ws1.send(JSON.stringify({
                    type: 'answer',
                    answer: answer.sdp
                }));
                log(1, 'ğŸ“¤ ã‚¢ãƒ³ã‚µãƒ¼é€ä¿¡');
            } catch (error) {
                log(1, 'âŒ ã‚ªãƒ•ã‚¡ãƒ¼å‡¦ç†å¤±æ•—: ' + error.message);
            }
        }

        async function handleOffer2(message) {
            try {
                if (!pc2) {
                    log(2, 'âŒ PeerConnectionãŒå­˜åœ¨ã—ã¾ã›ã‚“');
                    return;
                }
                
                log(2, 'ğŸ“¥ ã‚ªãƒ•ã‚¡ãƒ¼å—ä¿¡ã€å›ç­”ä½œæˆä¸­...');
                log(2, 'ğŸ” å—ä¿¡ã—ãŸã‚ªãƒ•ã‚¡ãƒ¼ãƒ‡ãƒ¼ã‚¿: ' + JSON.stringify(message));
                
                // Extract offer SDP from message structure
                let offerSdp;
                if (typeof message.offer === 'string') {
                    offerSdp = message.offer;
                } else if (message.offer && typeof message.offer.sdp === 'string') {
                    offerSdp = message.offer.sdp;
                } else {
                    log(2, 'âŒ ç„¡åŠ¹ãªã‚ªãƒ•ã‚¡ãƒ¼å½¢å¼ - ã‚ªãƒ•ã‚¡ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    log(2, 'ğŸ” ã‚ªãƒ•ã‚¡ãƒ¼ã®å‹: ' + typeof message.offer);
                    log(2, 'ğŸ” ã‚ªãƒ•ã‚¡ãƒ¼ã®å†…å®¹: ' + JSON.stringify(message.offer));
                    return;
                }
                
                log(2, 'âœ… ã‚ªãƒ•ã‚¡ãƒ¼SDPæŠ½å‡ºæˆåŠŸ: ' + offerSdp.substring(0, 100) + '...');
                
                // Create RTCSessionDescription
                const offer = new RTCSessionDescription({
                    type: 'offer',
                    sdp: offerSdp
                });
                
                await pc2.setRemoteDescription(offer);
                log(2, 'âœ… ãƒªãƒ¢ãƒ¼ãƒˆè¨˜è¿°è¨­å®šå®Œäº†');
                
                // Process any pending ICE candidates
                if (window.pendingIceCandidates2) {
                    for (const pendingCandidate of window.pendingIceCandidates2) {
                        await handleIceCandidate2(pendingCandidate);
                    }
                    window.pendingIceCandidates2 = [];
                    log(2, 'âœ… ä¿ç•™ä¸­ã®ICEå€™è£œã‚’å‡¦ç†ã—ã¾ã—ãŸ');
                }
                
                const answer = await pc2.createAnswer();
                await pc2.setLocalDescription(answer);
                
                ws2.send(JSON.stringify({
                    type: 'answer',
                    answer: answer.sdp
                }));
                log(2, 'ğŸ“¤ ã‚¢ãƒ³ã‚µãƒ¼é€ä¿¡');
            } catch (error) {
                log(2, 'âŒ ã‚ªãƒ•ã‚¡ãƒ¼å‡¦ç†å¤±æ•—: ' + error.message);
            }
        }

        async function handleAnswer1(message) {
            try {
                if (!pc1) {
                    log(1, 'âŒ PeerConnectionãŒå­˜åœ¨ã—ã¾ã›ã‚“');
                    return;
                }
                
                log(1, 'ğŸ“¥ ã‚¢ãƒ³ã‚µãƒ¼å—ä¿¡');
                
                // Extract answer SDP from message structure
                let answerSdp;
                if (typeof message.answer === 'string') {
                    answerSdp = message.answer;
                } else if (message.answer && typeof message.answer.sdp === 'string') {
                    answerSdp = message.answer.sdp;
                } else {
                    log(1, 'âŒ ç„¡åŠ¹ãªã‚¢ãƒ³ã‚µãƒ¼å½¢å¼');
                    return;
                }
                
                const answer = new RTCSessionDescription({
                    type: 'answer',
                    sdp: answerSdp
                });
                
                await pc1.setRemoteDescription(answer);
                updateStatus(1, 'ğŸ“ é€šè©±ä¸­', 'connected');
                log(1, 'âœ… ã‚¢ãƒ³ã‚µãƒ¼è¨­å®šå®Œäº†');
            } catch (error) {
                log(1, 'âŒ ã‚¢ãƒ³ã‚µãƒ¼å‡¦ç†å¤±æ•—: ' + error.message);
            }
        }

        async function handleAnswer2(message) {
            try {
                if (!pc2) {
                    log(2, 'âŒ PeerConnectionãŒå­˜åœ¨ã—ã¾ã›ã‚“');
                    return;
                }
                
                log(2, 'ğŸ“¥ ã‚¢ãƒ³ã‚µãƒ¼å—ä¿¡');
                
                // Extract answer SDP from message structure
                let answerSdp;
                if (typeof message.answer === 'string') {
                    answerSdp = message.answer;
                } else if (message.answer && typeof message.answer.sdp === 'string') {
                    answerSdp = message.answer.sdp;
                } else {
                    log(2, 'âŒ ç„¡åŠ¹ãªã‚¢ãƒ³ã‚µãƒ¼å½¢å¼');
                    return;
                }
                
                const answer = new RTCSessionDescription({
                    type: 'answer',
                    sdp: answerSdp
                });
                
                await pc2.setRemoteDescription(answer);
                updateStatus(2, 'ğŸ“ é€šè©±ä¸­', 'connected');
                log(2, 'âœ… ã‚¢ãƒ³ã‚µãƒ¼è¨­å®šå®Œäº†');
            } catch (error) {
                log(2, 'âŒ ã‚¢ãƒ³ã‚µãƒ¼å‡¦ç†å¤±æ•—: ' + error.message);
            }
        }

        async function handleIceCandidate1(message) {
            try {
                if (!pc1) {
                    log(1, 'âŒ PeerConnectionãŒå­˜åœ¨ã—ã¾ã›ã‚“');
                    return;
                }
                
                // Check if remote description is set
                if (!pc1.remoteDescription) {
                    log(1, 'âš ï¸ ãƒªãƒ¢ãƒ¼ãƒˆè¨˜è¿°ãŒæœªè¨­å®š - ICEå€™è£œã‚’ä¿å­˜');
                    // Queue ICE candidates if remote description is not set yet
                    if (!window.pendingIceCandidates1) {
                        window.pendingIceCandidates1 = [];
                    }
                    window.pendingIceCandidates1.push(message);
                    return;
                }
                
                const candidate = new RTCIceCandidate({
                    candidate: message.candidate.candidate,
                    sdpMLineIndex: message.candidate.sdpMLineIndex,
                    sdpMid: message.candidate.sdpMid
                });
                
                await pc1.addIceCandidate(candidate);
                log(1, 'âœ… ICEå€™è£œè¿½åŠ ');
            } catch (error) {
                log(1, 'âŒ ICEå€™è£œè¿½åŠ å¤±æ•—: ' + error.message);
            }
        }

        async function handleIceCandidate2(message) {
            try {
                if (!pc2) {
                    log(2, 'âŒ PeerConnectionãŒå­˜åœ¨ã—ã¾ã›ã‚“');
                    return;
                }
                
                // Check if remote description is set
                if (!pc2.remoteDescription) {
                    log(2, 'âš ï¸ ãƒªãƒ¢ãƒ¼ãƒˆè¨˜è¿°ãŒæœªè¨­å®š - ICEå€™è£œã‚’ä¿å­˜');
                    // Queue ICE candidates if remote description is not set yet
                    if (!window.pendingIceCandidates2) {
                        window.pendingIceCandidates2 = [];
                    }
                    window.pendingIceCandidates2.push(message);
                    return;
                }
                
                const candidate = new RTCIceCandidate({
                    candidate: message.candidate.candidate,
                    sdpMLineIndex: message.candidate.sdpMLineIndex,
                    sdpMid: message.candidate.sdpMid
                });
                
                await pc2.addIceCandidate(candidate);
                log(2, 'âœ… ICEå€™è£œè¿½åŠ ');
            } catch (error) {
                log(2, 'âŒ ICEå€™è£œè¿½åŠ å¤±æ•—: ' + error.message);
            }
        }

        // Audio control functions
        function toggleMute1() {
            if (localStream1) {
                const audioTrack = localStream1.getAudioTracks()[0];
                audioTrack.enabled = !audioTrack.enabled;
                isMuted1 = !audioTrack.enabled;
                
                document.getElementById('muteBtn1').textContent = isMuted1 ? 'ğŸ”‡ ãƒŸãƒ¥ãƒ¼ãƒˆè§£é™¤' : 'ğŸ¤ ãƒŸãƒ¥ãƒ¼ãƒˆ';
                log(1, isMuted1 ? 'ğŸ”‡ ãƒŸãƒ¥ãƒ¼ãƒˆ' : 'ğŸ¤ ãƒŸãƒ¥ãƒ¼ãƒˆè§£é™¤');
            }
        }

        function toggleMute2() {
            if (localStream2) {
                const audioTrack = localStream2.getAudioTracks()[0];
                audioTrack.enabled = !audioTrack.enabled;
                isMuted2 = !audioTrack.enabled;
                
                document.getElementById('muteBtn2').textContent = isMuted2 ? 'ğŸ”‡ ãƒŸãƒ¥ãƒ¼ãƒˆè§£é™¤' : 'ğŸ¤ ãƒŸãƒ¥ãƒ¼ãƒˆ';
                log(2, isMuted2 ? 'ğŸ”‡ ãƒŸãƒ¥ãƒ¼ãƒˆ' : 'ğŸ¤ ãƒŸãƒ¥ãƒ¼ãƒˆè§£é™¤');
            }
        }

        function toggleSpeaker1() {
            isSpeakerOn1 = !isSpeakerOn1;
            document.getElementById('speakerBtn1').textContent = isSpeakerOn1 ? 'ğŸ”‡ ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ OFF' : 'ğŸ“¢ ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ ON';
            log(1, isSpeakerOn1 ? 'ğŸ“¢ ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ ON' : 'ğŸ”‡ ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ OFF');
        }

        function toggleSpeaker2() {
            isSpeakerOn2 = !isSpeakerOn2;
            document.getElementById('speakerBtn2').textContent = isSpeakerOn2 ? 'ğŸ”‡ ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ OFF' : 'ğŸ“¢ ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ ON';
            log(2, isSpeakerOn2 ? 'ğŸ“¢ ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ ON' : 'ğŸ”‡ ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ OFF');
        }

        function endCall1() {
            if (pc1) {
                pc1.close();
                pc1 = null;
            }
            
            if (localStream1) {
                localStream1.getTracks().forEach(track => track.stop());
                localStream1 = null;
            }
            
            if (ws1 && currentMatch1) {
                ws1.send(JSON.stringify({
                    type: 'end-match',
                    matchId: currentMatch1.matchId
                }));
            }
            
            hideAudioControls1();
            resetMatchingState1();
            log(1, 'ğŸ“´ é€šè©±çµ‚äº†');
        }

        function endCall2() {
            if (pc2) {
                pc2.close();
                pc2 = null;
            }
            
            if (localStream2) {
                localStream2.getTracks().forEach(track => track.stop());
                localStream2 = null;
            }
            
            if (ws2 && currentMatch2) {
                ws2.send(JSON.stringify({
                    type: 'end-match',
                    matchId: currentMatch2.matchId
                }));
            }
            
            hideAudioControls2();
            resetMatchingState2();
            log(2, 'ğŸ“´ é€šè©±çµ‚äº†');
        }

        // UI state management
        function resetMatchingState1() {
            updateStatus(1, 'ğŸ”— æ¥ç¶šæ¸ˆã¿', 'connected');
            document.getElementById('matchBtn1').disabled = false;
            document.getElementById('cancelBtn1').disabled = true;
            document.getElementById('matchControls1').style.display = 'none';
            clearCountdown1();
            currentMatch1 = null;
        }

        function resetMatchingState2() {
            updateStatus(2, 'ğŸ”— æ¥ç¶šæ¸ˆã¿', 'connected');
            document.getElementById('matchBtn2').disabled = false;
            document.getElementById('cancelBtn2').disabled = true;
            document.getElementById('matchControls2').style.display = 'none';
            clearCountdown2();
            currentMatch2 = null;
        }

        function showAudioControls1() {
            document.getElementById('audioControls1').style.display = 'block';
        }

        function showAudioControls2() {
            document.getElementById('audioControls2').style.display = 'block';
        }

        function hideAudioControls1() {
            document.getElementById('audioControls1').style.display = 'none';
        }

        function hideAudioControls2() {
            document.getElementById('audioControls2').style.display = 'none';
        }

        function hideMatchControls1() {
            document.getElementById('matchControls1').style.display = 'none';
        }

        function hideMatchControls2() {
            document.getElementById('matchControls2').style.display = 'none';
        }

        // WebRTC helper functions
        async function createOffer1() {
            if (pc1) {
                try {
                    const offer = await pc1.createOffer();
                    await pc1.setLocalDescription(offer);
                    
                    ws1.send(JSON.stringify({
                        type: 'offer',
                        offer: {
                            sdp: offer.sdp,
                            type: offer.type
                        }
                    }));
                    log(1, 'ğŸ“¤ ã‚ªãƒ•ã‚¡ãƒ¼é€ä¿¡');
                } catch (error) {
                    log(1, `âŒ ã‚ªãƒ•ã‚¡ãƒ¼ä½œæˆå¤±æ•—: ${error.message}`);
                }
            }
        }
        
        async function createOffer2() {
            if (pc2) {
                try {
                    const offer = await pc2.createOffer();
                    await pc2.setLocalDescription(offer);
                    
                    ws2.send(JSON.stringify({
                        type: 'offer',
                        offer: {
                            sdp: offer.sdp,
                            type: offer.type
                        }
                    }));
                    log(2, 'ğŸ“¤ ã‚ªãƒ•ã‚¡ãƒ¼é€ä¿¡');
                } catch (error) {
                    log(2, `âŒ ã‚ªãƒ•ã‚¡ãƒ¼ä½œæˆå¤±æ•—: ${error.message}`);
                }
            }
        }
        
        async function handleOffer1(message) {
            if (pc1) {
                try {
                    log(1, 'ğŸ“¥ ã‚ªãƒ•ã‚¡ãƒ¼å—ä¿¡ã€å›ç­”ä½œæˆä¸­...');
                    await pc1.setRemoteDescription(new RTCSessionDescription(message.offer));
                    
                    const answer = await pc1.createAnswer();
                    await pc1.setLocalDescription(answer);
                    
                    ws1.send(JSON.stringify({
                        type: 'answer',
                        answer: {
                            sdp: answer.sdp,
                            type: answer.type
                        }
                    }));
                    log(1, 'ğŸ“¤ å›ç­”é€ä¿¡');
                } catch (error) {
                    log(1, `âŒ ã‚ªãƒ•ã‚¡ãƒ¼å‡¦ç†å¤±æ•—: ${error.message}`);
                }
            }
        }
        
        async function handleOffer2(message) {
            if (pc2) {
                try {
                    log(2, 'ğŸ“¥ ã‚ªãƒ•ã‚¡ãƒ¼å—ä¿¡ã€å›ç­”ä½œæˆä¸­...');
                    await pc2.setRemoteDescription(new RTCSessionDescription(message.offer));
                    
                    const answer = await pc2.createAnswer();
                    await pc2.setLocalDescription(answer);
                    
                    ws2.send(JSON.stringify({
                        type: 'answer',
                        answer: {
                            sdp: answer.sdp,
                            type: answer.type
                        }
                    }));
                    log(2, 'ğŸ“¤ å›ç­”é€ä¿¡');
                } catch (error) {
                    log(2, `âŒ ã‚ªãƒ•ã‚¡ãƒ¼å‡¦ç†å¤±æ•—: ${error.message}`);
                }
            }
        }
        
        async function handleAnswer1(message) {
            if (pc1) {
                try {
                    log(1, 'ğŸ“¥ å›ç­”å—ä¿¡');
                    await pc1.setRemoteDescription(new RTCSessionDescription(message.answer));
                } catch (error) {
                    log(1, `âŒ å›ç­”å‡¦ç†å¤±æ•—: ${error.message}`);
                }
            }
        }
        
        async function handleAnswer2(message) {
            if (pc2) {
                try {
                    log(2, 'ğŸ“¥ å›ç­”å—ä¿¡');
                    await pc2.setRemoteDescription(new RTCSessionDescription(message.answer));
                } catch (error) {
                    log(2, `âŒ å›ç­”å‡¦ç†å¤±æ•—: ${error.message}`);
                }
            }
        }
        
        async function handleIceCandidate1(message) {
            if (pc1) {
                try {
                    await pc1.addIceCandidate(new RTCIceCandidate(message.candidate));
                    log(1, 'ğŸ§Š ICEå€™è£œè¿½åŠ ');
                } catch (error) {
                    log(1, `âŒ ICEå€™è£œè¿½åŠ å¤±æ•—: ${error.message}`);
                }
            }
        }
        
        async function handleIceCandidate2(message) {
            if (pc2) {
                try {
                    await pc2.addIceCandidate(new RTCIceCandidate(message.candidate));
                    log(2, 'ğŸ§Š ICEå€™è£œè¿½åŠ ');
                } catch (error) {
                    log(2, `âŒ ICEå€™è£œè¿½åŠ å¤±æ•—: ${error.message}`);
                }
            }
        }

        // Auto-connect both users when page loads
        window.onload = () => {
            log(1, 'ğŸš€ ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†');
            log(2, 'ğŸš€ ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†');
            
            // Check browser support first
            if (!checkBrowserSupport()) {
                return;
            }
            
            // Auto-connect both users after 1 second
            setTimeout(() => {
                connectUser1();
                setTimeout(() => {
                    connectUser2();
                }, 500);
            }, 1000);
        };
    </script>
</body>
</html>