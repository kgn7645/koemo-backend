<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KOEMO ãƒ¢ãƒã‚¤ãƒ«ãƒãƒƒãƒãƒ³ã‚°éŸ³å£°ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            padding: 20px;
            background: #f2f2f7;
            margin: 0;
        }
        .container {
            max-width: 400px;
            margin: 0 auto;
        }
        h1 {
            color: #007AFF;
            text-align: center;
            font-size: 24px;
            margin-bottom: 30px;
        }
        .status {
            background: #fff;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .status.connected { background: #d4edda; }
        .status.error { background: #f8d7da; }
        .status.warning { background: #fff3cd; }
        .status.matching { background: #ffeaa7; }
        
        button {
            width: 100%;
            background: #007AFF;
            color: white;
            border: none;
            padding: 15px;
            border-radius: 10px;
            font-size: 16px;
            margin: 10px 0;
            cursor: pointer;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        button.danger {
            background: #ff3b30;
        }
        button.success {
            background: #34c759;
        }
        button.warning {
            background: #ff9500;
        }
        
        .log {
            background: #fff;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            border: 1px solid #ddd;
        }
        
        .user-id {
            background: #e9ecef;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 14px;
            word-break: break-all;
        }
        
        .volume-indicator {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        .volume-bar {
            height: 100%;
            background: #34c759;
            width: 0%;
            transition: width 0.1s;
        }
        
        .partner-info {
            background: #fff;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¯ KOEMO ãƒ¢ãƒã‚¤ãƒ«ãƒãƒƒãƒãƒ³ã‚°</h1>
        
        <div class="user-id">
            ãƒ¦ãƒ¼ã‚¶ãƒ¼ID: <span id="userId">ç”Ÿæˆä¸­...</span>
        </div>
        
        <div id="connectionStatus" class="status">
            ğŸ“¡ æ¥ç¶šæº–å‚™ä¸­...
        </div>
        
        <button id="connectBtn" onclick="connectWebSocket()">WebSocketæ¥ç¶š</button>
        <button id="startMatchingBtn" onclick="startMatching()" disabled>ãƒãƒƒãƒãƒ³ã‚°é–‹å§‹</button>
        <button id="cancelMatchingBtn" onclick="cancelMatching()" disabled style="display:none;">ãƒãƒƒãƒãƒ³ã‚°ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button id="endCallBtn" onclick="endCall()" disabled style="display:none;">é€šè©±çµ‚äº†</button>
        
        <div id="matchingStatus" class="status" style="display:none;">
            ãƒãƒƒãƒãƒ³ã‚°çŠ¶æ…‹: å¾…æ©Ÿä¸­
        </div>
        
        <div id="partnerInfo" class="partner-info">
            <div>é€šè©±ç›¸æ‰‹: <span id="partnerName">-</span></div>
            <div>é€šè©±æ™‚é–“: <span id="callDuration">00:00</span></div>
        </div>
        
        <div id="volumeContainer" style="display:none;">
            <div>éŸ³é‡ãƒ¬ãƒ™ãƒ«:</div>
            <div class="volume-indicator">
                <div id="volumeBar" class="volume-bar"></div>
            </div>
        </div>
        
        <div id="log" class="log"></div>
    </div>

    <script>
        let ws = null;
        let localStream = null;
        let remoteStream = null;
        let peerConnection = null;
        let isMatching = false;
        let inCall = false;
        let userId = 'mobile_' + Math.random().toString(36).substr(2, 9);
        let callStartTime = null;
        let callTimer = null;
        
        // Initialize
        document.getElementById('userId').textContent = userId;
        
        function log(message) {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }
        
        function updateStatus(message, type = 'normal') {
            const statusDiv = document.getElementById('connectionStatus');
            statusDiv.textContent = message;
            statusDiv.className = 'status';
            if (type === 'connected') statusDiv.classList.add('connected');
            if (type === 'error') statusDiv.classList.add('error');
            if (type === 'warning') statusDiv.classList.add('warning');
            if (type === 'matching') statusDiv.classList.add('matching');
        }
        
        function updateButtons() {
            document.getElementById('connectBtn').disabled = (ws && ws.readyState === WebSocket.OPEN);
            document.getElementById('startMatchingBtn').disabled = !(ws && ws.readyState === WebSocket.OPEN) || isMatching || inCall;
            document.getElementById('cancelMatchingBtn').style.display = isMatching ? 'block' : 'none';
            document.getElementById('endCallBtn').style.display = inCall ? 'block' : 'none';
        }
        
        async function connectWebSocket() {
            try {
                log('ğŸ”Œ WebSocketæ¥ç¶šã‚’é–‹å§‹...');
                updateStatus('ğŸ”Œ WebSocketæ¥ç¶šä¸­...', 'warning');
                
                const wsUrl = `ws://192.168.0.8:3000/signaling?userId=${userId}`;
                log(`æ¥ç¶šå…ˆ: ${wsUrl}`);
                
                ws = new WebSocket(wsUrl);
                
                ws.onopen = function() {
                    log('âœ… WebSocketæ¥ç¶šæˆåŠŸ');
                    updateStatus('âœ… WebSocketæ¥ç¶šæ¸ˆã¿', 'connected');
                    updateButtons();
                };
                
                ws.onmessage = function(event) {
                    try {
                        const message = JSON.parse(event.data);
                        log(`ğŸ“¨ å—ä¿¡: ${message.type}`);
                        handleWebSocketMessage(message);
                    } catch (error) {
                        log(`âŒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è§£æã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    }
                };
                
                ws.onclose = function() {
                    log('âŒ WebSocketæ¥ç¶šãŒé–‰ã˜ã‚‰ã‚Œã¾ã—ãŸ');
                    updateStatus('âŒ WebSocketåˆ‡æ–­', 'error');
                    
                    // é€šè©±ä¸­ã®å ´åˆã¯è‡ªå‹•å†æ¥ç¶šã‚’è©¦è¡Œ
                    if (inCall) {
                        log('ğŸ”„ é€šè©±ä¸­ã®ãŸã‚å†æ¥ç¶šã‚’è©¦è¡Œ...');
                        setTimeout(() => {
                            if (inCall) {
                                connectWebSocket();
                            }
                        }, 2000);
                    }
                    
                    updateButtons();
                };
                
                ws.onerror = function(error) {
                    log(`âŒ WebSocketã‚¨ãƒ©ãƒ¼: ${error}`);
                    updateStatus('âŒ WebSocketæ¥ç¶šã‚¨ãƒ©ãƒ¼', 'error');
                    updateButtons();
                };
                
            } catch (error) {
                log(`âŒ WebSocketæ¥ç¶šã‚¨ãƒ©ãƒ¼: ${error.message}`);
                updateStatus('âŒ æ¥ç¶šå¤±æ•—', 'error');
            }
        }
        
        function handleWebSocketMessage(message) {
            switch (message.type) {
                case 'connected':
                    log(`ğŸ¯ ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šç¢ºèª: ${message.userId}`);
                    break;
                    
                case 'matching-status':
                    log(`ğŸ” ãƒãƒƒãƒãƒ³ã‚°çŠ¶æ³: ${message.queueSize}äººå¾…æ©Ÿä¸­`);
                    document.getElementById('matchingStatus').style.display = 'block';
                    document.getElementById('matchingStatus').textContent = `ãƒãƒƒãƒãƒ³ã‚°ä¸­... (${message.queueSize}äººå¾…æ©Ÿ)`;
                    break;
                    
                case 'match-found':
                    log(`ğŸ‰ ãƒãƒƒãƒæˆåŠŸ! ç›¸æ‰‹: ${message.partnerId}`);
                    document.getElementById('partnerInfo').style.display = 'block';
                    document.getElementById('partnerName').textContent = message.partnerId;
                    isMatching = false;
                    inCall = true;
                    updateButtons();
                    updateStatus('ğŸ“ é€šè©±æº–å‚™ä¸­...', 'warning');
                    startCall();
                    
                    // ãƒãƒƒãƒæˆåŠŸå¾Œã€å°‘ã—å¾…ã£ã¦ã‹ã‚‰Offerã‚’ä½œæˆï¼ˆãƒ¢ãƒã‚¤ãƒ«å´ã‹ã‚‰ï¼‰
                    setTimeout(async () => {
                        if (peerConnection && peerConnection.localDescription === null) {
                            try {
                                const offer = await peerConnection.createOffer();
                                await peerConnection.setLocalDescription(offer);
                                
                                if (ws && ws.readyState === WebSocket.OPEN) {
                                    ws.send(JSON.stringify({
                                        type: 'offer',
                                        offer: offer
                                    }));
                                    log('ğŸ“¤ Offeré€ä¿¡ï¼ˆãƒ¢ãƒã‚¤ãƒ«ç™ºä¿¡ï¼‰');
                                }
                            } catch (error) {
                                log(`âŒ Offerä½œæˆã‚¨ãƒ©ãƒ¼: ${error.message}`);
                            }
                        }
                    }, 1000);
                    break;
                    
                case 'match-cancelled':
                    log('âŒ ãƒãƒƒãƒãƒ³ã‚°ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ');
                    isMatching = false;
                    document.getElementById('matchingStatus').style.display = 'none';
                    updateButtons();
                    updateStatus('âœ… WebSocketæ¥ç¶šæ¸ˆã¿', 'connected');
                    break;
                    
                case 'call-ended':
                    log('ğŸ“´ é€šè©±ãŒçµ‚äº†ã—ã¾ã—ãŸ');
                    endCall();
                    break;
                    
                case 'offer':
                    log('ğŸ“¥ Offerå—ä¿¡');
                    handleWebRTCOffer(message);
                    break;
                    
                case 'answer':
                    log('ğŸ“¥ Answerå—ä¿¡');
                    handleWebRTCAnswer(message);
                    break;
                    
                case 'ice-candidate':
                    log('ğŸ§Š ICEå€™è£œå—ä¿¡');
                    handleWebRTCIceCandidate(message);
                    break;
                    
                default:
                    log(`â“ ä¸æ˜ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: ${message.type}`);
            }
        }
        
        async function startMatching() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('âŒ WebSocketæœªæ¥ç¶š');
                return;
            }
            
            try {
                log('ğŸ¯ ãƒãƒƒãƒãƒ³ã‚°é–‹å§‹...');
                isMatching = true;
                updateButtons();
                
                const message = {
                    type: 'start-matching',
                    profile: {
                        nickname: 'ãƒ¢ãƒã‚¤ãƒ«ãƒ¦ãƒ¼ã‚¶ãƒ¼',
                        gender: 'unknown',
                        age: 25,
                        region: 'Mobile'
                    }
                };
                
                ws.send(JSON.stringify(message));
                log('ğŸ“¤ ãƒãƒƒãƒãƒ³ã‚°ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡');
                updateStatus('ğŸ” ãƒãƒƒãƒãƒ³ã‚°ä¸­...', 'matching');
                
            } catch (error) {
                log(`âŒ ãƒãƒƒãƒãƒ³ã‚°é–‹å§‹ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                isMatching = false;
                updateButtons();
            }
        }
        
        function cancelMatching() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            
            try {
                ws.send(JSON.stringify({ type: 'cancel-matching' }));
                log('ğŸš« ãƒãƒƒãƒãƒ³ã‚°ã‚­ãƒ£ãƒ³ã‚»ãƒ«');
                isMatching = false;
                document.getElementById('matchingStatus').style.display = 'none';
                updateButtons();
                updateStatus('âœ… WebSocketæ¥ç¶šæ¸ˆã¿', 'connected');
            } catch (error) {
                log(`âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }
        
        async function startCall() {
            try {
                log('ğŸ¤ éŸ³å£°ãƒ‡ãƒã‚¤ã‚¹åˆæœŸåŒ–...');
                
                // ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                log('âœ… ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯å–å¾—');
                
                // éŸ³é‡è¡¨ç¤º
                document.getElementById('volumeContainer').style.display = 'block';
                setupVolumeIndicator();
                
                // WebRTCåˆæœŸåŒ–
                initWebRTC();
                
                // é€šè©±é–‹å§‹æ™‚é–“è¨˜éŒ²
                callStartTime = new Date();
                startCallTimer();
                
                updateStatus('ğŸ“ é€šè©±ä¸­', 'connected');
                
            } catch (error) {
                log(`âŒ éŸ³å£°åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                updateStatus('âŒ éŸ³å£°ã‚¨ãƒ©ãƒ¼', 'error');
            }
        }
        
        function startCallTimer() {
            callTimer = setInterval(() => {
                if (callStartTime) {
                    const elapsed = Math.floor((new Date() - callStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('callDuration').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }
        
        function initWebRTC() {
            // WebRTCè¨­å®š
            const configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' }
                ]
            };
            
            peerConnection = new RTCPeerConnection(configuration);
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿½åŠ 
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
            
            // ãƒªãƒ¢ãƒ¼ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ å—ä¿¡
            peerConnection.ontrack = function(event) {
                log('ğŸµ ãƒªãƒ¢ãƒ¼ãƒˆéŸ³å£°å—ä¿¡');
                remoteStream = event.streams[0];
                
                // ãƒªãƒ¢ãƒ¼ãƒˆéŸ³å£°ã‚’å†ç”Ÿ
                const audio = new Audio();
                audio.srcObject = remoteStream;
                audio.play().catch(e => log(`éŸ³å£°å†ç”Ÿã‚¨ãƒ©ãƒ¼: ${e.message}`));
            };
            
            // ICEå€™è£œç”Ÿæˆ
            peerConnection.onicecandidate = function(event) {
                if (event.candidate) {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'ice-candidate',
                            candidate: event.candidate
                        }));
                        log('ğŸ§Š ICEå€™è£œé€ä¿¡');
                    } else {
                        log('âŒ WebSocketåˆ‡æ–­ä¸­ - ICEå€™è£œé€ä¿¡å¤±æ•—');
                    }
                }
            };
            
            log('ğŸ”— WebRTCåˆæœŸåŒ–å®Œäº†');
        }
        
        async function handleWebRTCOffer(message) {
            try {
                if (!peerConnection) initWebRTC();
                
                await peerConnection.setRemoteDescription(new RTCSessionDescription(message.offer));
                log('ğŸ“¥ Offerè¨­å®šå®Œäº†');
                
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'answer',
                        answer: answer
                    }));
                    log('ğŸ“¤ Answeré€ä¿¡');
                } else {
                    log('âŒ WebSocketåˆ‡æ–­ä¸­ - Answeré€ä¿¡å¤±æ•—');
                }
                
            } catch (error) {
                log(`âŒ Offerå‡¦ç†ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }
        
        async function handleWebRTCAnswer(message) {
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer));
                log('ğŸ“¥ Answerè¨­å®šå®Œäº†');
            } catch (error) {
                log(`âŒ Answerå‡¦ç†ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }
        
        async function handleWebRTCIceCandidate(message) {
            try {
                await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
                log('ğŸ§Š ICEå€™è£œè¿½åŠ å®Œäº†');
            } catch (error) {
                log(`âŒ ICEå€™è£œã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }
        
        function setupVolumeIndicator() {
            if (!localStream) return;
            
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(localStream);
            const analyser = audioContext.createAnalyser();
            
            source.connect(analyser);
            analyser.fftSize = 256;
            
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            
            function updateVolume() {
                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                const volumePercent = (average / 255) * 100;
                
                document.getElementById('volumeBar').style.width = volumePercent + '%';
                
                if (inCall) {
                    requestAnimationFrame(updateVolume);
                }
            }
            
            updateVolume();
        }
        
        function endCall() {
            try {
                log('ğŸ“´ é€šè©±çµ‚äº†å‡¦ç†...');
                
                if (callTimer) {
                    clearInterval(callTimer);
                    callTimer = null;
                }
                
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'end-call' }));
                }
                
                inCall = false;
                isMatching = false;
                callStartTime = null;
                
                document.getElementById('partnerInfo').style.display = 'none';
                document.getElementById('volumeContainer').style.display = 'none';
                document.getElementById('matchingStatus').style.display = 'none';
                
                updateButtons();
                updateStatus('âœ… WebSocketæ¥ç¶šæ¸ˆã¿', 'connected');
                
                log('âœ… é€šè©±çµ‚äº†å®Œäº†');
                
            } catch (error) {
                log(`âŒ é€šè©±çµ‚äº†ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }
        
        // è‡ªå‹•æ¥ç¶š
        window.onload = function() {
            log('ğŸ“± ãƒ¢ãƒã‚¤ãƒ«ãƒãƒƒãƒãƒ³ã‚°ãƒ†ã‚¹ãƒˆé–‹å§‹');
            updateButtons();
        };
        
        // Page visibility API
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                log('ğŸ“µ ãƒšãƒ¼ã‚¸ãŒéè¡¨ç¤ºã«ãªã‚Šã¾ã—ãŸ');
            } else {
                log('ğŸ“± ãƒšãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã¾ã—ãŸ');
            }
        });
    </script>
</body>
</html>